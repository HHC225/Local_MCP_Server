"""
Conversation Memory Tool Wrappers for MCP Registration
"""
from fastmcp import Context
from src.tools.memory.conversation_memory_tool import ConversationMemoryTool
from configs.memory import MemoryConfig

# Initialize tool instance
_memory_tool = ConversationMemoryTool(
    persist_directory=str(MemoryConfig.CONVERSATION_MEMORY_DB_PATH)
)


async def conversation_memory_store(
    conversation_text: str,
    speaker: str = None,
    summary: str = None,
    metadata: dict = None,
    conversation_id: str = None,
    ctx: Context = None
) -> dict:
    """
    Store important conversation content in vector database.
    
    This tool stores conversation summaries or full text in ChromaDB with automatic embedding.
    The LLM should provide a summary of important conversation points before calling this tool.
    
    Args:
        conversation_text: The full conversation content to store
        speaker: Name of the speaker/participant (e.g., "User", "GitHub Copilot", "Assistant")
        summary: Summary of the conversation (recommended - should be generated by LLM)
        metadata: Additional metadata as dict (e.g., {"topic": "API design", "importance": "high"})
        conversation_id: Optional unique identifier (auto-generated if not provided)
    
    Returns:
        dict: Storage confirmation with conversation_id and metadata
    
    Example:
        Store a summarized conversation:
        {
            "conversation_text": "User asked about API design patterns. Discussed REST vs GraphQL...",
            "speaker": "GitHub Copilot",
            "summary": "Discussion about API design: REST vs GraphQL trade-offs, recommended REST for simple CRUD",
            "metadata": {"topic": "API design", "context": "architecture planning"}
        }
    """
    return await _memory_tool.execute(
        action="store",
        ctx=ctx,
        conversation_text=conversation_text,
        speaker=speaker,
        summary=summary,
        metadata=metadata,
        conversation_id=conversation_id
    )


async def conversation_memory_query(
    query_text: str,
    n_results: int = None,
    filter_metadata: dict = None,
    ctx: Context = None
) -> dict:
    """
    Query stored conversations using semantic search.
    
    This tool searches the vector database for relevant conversation memories
    based on semantic similarity to the query text.
    
    Args:
        query_text: Text to search for (will find semantically similar conversations)
        n_results: Number of results to return (default: 5)
        filter_metadata: Optional metadata filters as dict (e.g., {"speaker": "User"})
    
    Returns:
        dict: Search results with relevant conversations and their metadata
    
    Example:
        Find conversations about database design:
        {
            "query_text": "How should I design the database schema?",
            "n_results": 3,
            "filter_metadata": {"topic": "database"}
        }
    """
    if n_results is None:
        n_results = MemoryConfig.CONVERSATION_MEMORY_DEFAULT_RESULTS
        
    return await _memory_tool.execute(
        action="query",
        ctx=ctx,
        query_text=query_text,
        n_results=n_results,
        filter_metadata=filter_metadata
    )


async def conversation_memory_list(
    limit: int = None,
    offset: int = 0,
    ctx: Context = None
) -> dict:
    """
    List all stored conversation memories.
    
    Args:
        limit: Maximum number of conversations to return (None = all)
        offset: Number of conversations to skip
    
    Returns:
        dict: List of all stored conversations with metadata
    """
    return await _memory_tool.execute(
        action="list",
        ctx=ctx,
        limit=limit,
        offset=offset
    )


async def conversation_memory_delete(
    conversation_id: str,
    ctx: Context = None
) -> dict:
    """
    Delete a specific conversation from the database.
    
    Args:
        conversation_id: ID of the conversation to delete
    
    Returns:
        dict: Deletion confirmation
    """
    return await _memory_tool.execute(
        action="delete",
        ctx=ctx,
        conversation_id=conversation_id
    )


async def conversation_memory_clear(
    ctx: Context = None
) -> dict:
    """
    Clear all conversations from the database.
    
    WARNING: This will permanently delete all stored conversation memories.
    
    Returns:
        dict: Clear confirmation with count of deleted items
    """
    return await _memory_tool.execute(
        action="clear",
        ctx=ctx
    )


async def conversation_memory_get(
    conversation_id: str,
    ctx: Context = None
) -> dict:
    """
    Get a specific conversation by ID.
    
    This tool retrieves the full content and metadata of a specific conversation.
    Useful for reviewing or editing existing conversation entries.
    
    Args:
        conversation_id: ID of the conversation to retrieve
    
    Returns:
        dict: Conversation data including document and metadata
    
    Example:
        Get conversation to review before updating:
        {
            "conversation_id": "conv_20250117_143022_123456"
        }
    """
    return await _memory_tool.execute(
        action="get",
        ctx=ctx,
        conversation_id=conversation_id
    )


async def conversation_memory_update(
    conversation_id: str,
    conversation_text: str = None,
    speaker: str = None,
    summary: str = None,
    metadata: dict = None,
    merge_metadata: bool = True,
    ctx: Context = None
) -> dict:
    """
    Update an existing conversation in the database.
    
    This tool allows you to modify existing conversation entries. You can update
    the conversation text, speaker, summary, and/or metadata. By default, metadata
    is merged with existing metadata, but you can choose to replace it completely.
    
    Args:
        conversation_id: ID of the conversation to update (required)
        conversation_text: New conversation content (optional, keeps existing if None)
        speaker: New speaker name (optional, updates if provided)
        summary: New summary (optional, updates if provided)
        metadata: New metadata dict (optional, merged or replaced based on merge_metadata)
        merge_metadata: If True, merge with existing metadata; if False, replace completely (default: True)
    
    Returns:
        dict: Update confirmation with conversation_id and updated metadata
    
    Example 1 - Update conversation text and summary:
        {
            "conversation_id": "conv_20250117_143022_123456",
            "conversation_text": "Updated discussion about API design patterns...",
            "summary": "Revised discussion: Decided to use REST instead of GraphQL",
            "merge_metadata": True
        }
    
    Example 2 - Add new metadata while keeping existing:
        {
            "conversation_id": "conv_20250117_143022_123456",
            "metadata": {"status": "resolved", "priority": "high"},
            "merge_metadata": True
        }
    
    Example 3 - Replace all metadata:
        {
            "conversation_id": "conv_20250117_143022_123456",
            "metadata": {"topic": "new_topic", "importance": "low"},
            "merge_metadata": False
        }
    
    Workflow:
        1. Use conversation_memory_get to retrieve existing conversation
        2. Review and modify the content
        3. Use conversation_memory_update to save changes
    """
    return await _memory_tool.execute(
        action="update",
        ctx=ctx,
        conversation_id=conversation_id,
        conversation_text=conversation_text,
        speaker=speaker,
        summary=summary,
        metadata=metadata,
        merge_metadata=merge_metadata
    )
