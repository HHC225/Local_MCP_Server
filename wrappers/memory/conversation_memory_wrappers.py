"""
Conversation Memory Tool Wrappers for MCP Registration
"""
from fastmcp import Context
from tools.memory.conversation_memory_tool import ConversationMemoryTool
from config import ServerConfig

# Initialize tool instance
_memory_tool = ConversationMemoryTool(
    persist_directory=ServerConfig.CONVERSATION_MEMORY_DB_PATH
)


async def conversation_memory_store(
    conversation_text: str,
    speaker: str = None,
    summary: str = None,
    metadata: dict = None,
    conversation_id: str = None,
    ctx: Context = None
) -> dict:
    """
    Store important conversation content in vector database.
    
    This tool stores conversation summaries or full text in ChromaDB with automatic embedding.
    The LLM should provide a summary of important conversation points before calling this tool.
    
    Args:
        conversation_text: The full conversation content to store
        speaker: Name of the speaker/participant (e.g., "User", "GitHub Copilot", "Assistant")
        summary: Summary of the conversation (recommended - should be generated by LLM)
        metadata: Additional metadata as dict (e.g., {"topic": "API design", "importance": "high"})
        conversation_id: Optional unique identifier (auto-generated if not provided)
    
    Returns:
        dict: Storage confirmation with conversation_id and metadata
    
    Example:
        Store a summarized conversation:
        {
            "conversation_text": "User asked about API design patterns. Discussed REST vs GraphQL...",
            "speaker": "GitHub Copilot",
            "summary": "Discussion about API design: REST vs GraphQL trade-offs, recommended REST for simple CRUD",
            "metadata": {"topic": "API design", "context": "architecture planning"}
        }
    """
    return await _memory_tool.execute(
        action="store",
        ctx=ctx,
        conversation_text=conversation_text,
        speaker=speaker,
        summary=summary,
        metadata=metadata,
        conversation_id=conversation_id
    )


async def conversation_memory_query(
    query_text: str,
    n_results: int = None,
    filter_metadata: dict = None,
    ctx: Context = None
) -> dict:
    """
    Query stored conversations using semantic search.
    
    This tool searches the vector database for relevant conversation memories
    based on semantic similarity to the query text.
    
    Args:
        query_text: Text to search for (will find semantically similar conversations)
        n_results: Number of results to return (default: 5)
        filter_metadata: Optional metadata filters as dict (e.g., {"speaker": "User"})
    
    Returns:
        dict: Search results with relevant conversations and their metadata
    
    Example:
        Find conversations about database design:
        {
            "query_text": "How should I design the database schema?",
            "n_results": 3,
            "filter_metadata": {"topic": "database"}
        }
    """
    if n_results is None:
        n_results = ServerConfig.CONVERSATION_MEMORY_DEFAULT_RESULTS
        
    return await _memory_tool.execute(
        action="query",
        ctx=ctx,
        query_text=query_text,
        n_results=n_results,
        filter_metadata=filter_metadata
    )


async def conversation_memory_list(
    limit: int = None,
    offset: int = 0,
    ctx: Context = None
) -> dict:
    """
    List all stored conversation memories.
    
    Args:
        limit: Maximum number of conversations to return (None = all)
        offset: Number of conversations to skip
    
    Returns:
        dict: List of all stored conversations with metadata
    """
    return await _memory_tool.execute(
        action="list",
        ctx=ctx,
        limit=limit,
        offset=offset
    )


async def conversation_memory_delete(
    conversation_id: str,
    ctx: Context = None
) -> dict:
    """
    Delete a specific conversation from the database.
    
    Args:
        conversation_id: ID of the conversation to delete
    
    Returns:
        dict: Deletion confirmation
    """
    return await _memory_tool.execute(
        action="delete",
        ctx=ctx,
        conversation_id=conversation_id
    )


async def conversation_memory_clear(
    ctx: Context = None
) -> dict:
    """
    Clear all conversations from the database.
    
    WARNING: This will permanently delete all stored conversation memories.
    
    Returns:
        dict: Clear confirmation with count of deleted items
    """
    return await _memory_tool.execute(
        action="clear",
        ctx=ctx
    )
